"""
Differential operators on tensors: Lie derivative, exterior derivative, etc.
"""

from typing import Optional
import numpy as np

from tas.core.tensor import Tensor
from tas.core.connections import Connection, covariant_derivative


def lie_derivative(tensor: Tensor, vector_field: Tensor, 
                   connection: Optional[Connection] = None) -> Tensor:
    """
    Compute Lie derivative of a tensor along a vector field.
    
    The Lie derivative L_X T measures how tensor T changes along
    the flow generated by vector field X.
    
    For a scalar function f: L_X f = X^i ∂_i f
    For a vector V: L_X V^i = X^j ∂_j V^i - V^j ∂_j X^i
    
    Args:
        tensor: Tensor to differentiate
        vector_field: Vector field X along which to differentiate
        connection: Optional connection (not used in pure Lie derivative)
        
    Returns:
        Lie derivative L_X T
        
    Note:
        Current implementation is simplified for constant tensors.
        Full implementation requires coordinate-aware differentiation.
    """
    if vector_field.ndim != 1:
        raise ValueError("Vector field must be rank-1 tensor")
    
    if vector_field.indices[0].variance != "up":
        raise ValueError("Vector field must have contravariant index (up)")
    
    # Simplified: for constant tensors, Lie derivative involves only
    # the commutator terms
    # Full implementation would require actual differentiation
    
    raise NotImplementedError(
        "Lie derivative requires coordinate-aware differentiation. "
        "Use covariant_derivative for connection-based derivatives."
    )


def exterior_derivative(form: Tensor) -> Tensor:
    """
    Compute exterior derivative of a differential form.
    
    The exterior derivative d maps k-forms to (k+1)-forms and satisfies:
    - d(d(ω)) = 0 (nilpotent)
    - d(ω ∧ η) = dω ∧ η + (-1)^k ω ∧ dη (Leibniz rule)
    
    Args:
        form: Antisymmetric tensor (differential form)
        
    Returns:
        Exterior derivative d(form)
        
    Note:
        Requires coordinate-aware implementation.
    """
    raise NotImplementedError(
        "Exterior derivative requires coordinate-aware differentiation"
    )


def gradient(scalar_field: Tensor, metric: Optional[Tensor] = None) -> Tensor:
    """
    Compute gradient of a scalar field.
    
    For a scalar f, the gradient is:
    - With metric: ∇f = g^ij ∂_j f (contravariant vector)
    - Without metric: ∂_i f (covariant vector)
    
    Args:
        scalar_field: Rank-0 tensor (scalar)
        metric: Optional metric for raising index
        
    Returns:
        Gradient vector
        
    Note:
        Requires coordinate-aware differentiation.
    """
    if scalar_field.ndim != 0:
        raise ValueError("Gradient requires rank-0 tensor (scalar)")
    
    raise NotImplementedError(
        "Gradient computation requires coordinate-aware differentiation"
    )


def divergence(vector_field: Tensor, connection: Connection) -> Tensor:
    """
    Compute divergence of a vector field.
    
    For vector V^i: div(V) = ∇_i V^i (contraction of covariant derivative)
    
    Args:
        vector_field: Rank-1 contravariant tensor
        connection: Connection for covariant derivative
        
    Returns:
        Scalar (rank-0 tensor) representing divergence
    """
    if vector_field.ndim != 1:
        raise ValueError("Divergence requires rank-1 tensor (vector)")
    
    if vector_field.indices[0].variance != "up":
        raise ValueError("Divergence requires contravariant vector")
    
    # Compute covariant derivative ∇_j V^i
    cov_deriv = covariant_derivative(vector_field, connection)
    
    # Contract over both indices to get scalar
    # ∇_i V^i
    result = 0.0
    for i in range(vector_field.shape[0]):
        result += cov_deriv.data[i, i]
    
    return Tensor(
        data=np.array(result),
        indices=(),
        name=f"div({vector_field.name or 'V'})",
        backend=vector_field.backend,
        meta=vector_field.meta
    )


def curl(vector_field: Tensor) -> Tensor:
    """
    Compute curl of a vector field in 3D.
    
    For 3D vector V: curl(V)_i = ε_ijk ∂_j V_k
    
    Args:
        vector_field: 3D vector field
        
    Returns:
        Curl vector (3D antisymmetric part of derivative)
        
    Note:
        Requires coordinate-aware differentiation.
    """
    if vector_field.ndim != 1 or vector_field.shape[0] != 3:
        raise ValueError("Curl requires 3D vector field")
    
    raise NotImplementedError(
        "Curl computation requires coordinate-aware differentiation"
    )


def laplacian(tensor: Tensor, connection: Connection, 
              metric: Optional[Tensor] = None) -> Tensor:
    """
    Compute Laplacian (Laplace-Beltrami operator) of a tensor.
    
    For a scalar f: Δf = g^ij ∇_i ∇_j f
    For a vector: Δ V^i = g^jk ∇_j ∇_k V^i
    
    Args:
        tensor: Tensor to apply Laplacian to
        connection: Connection for covariant derivatives
        metric: Metric for raising indices
        
    Returns:
        Laplacian of tensor (same rank as input)
        
    Note:
        Requires iterated covariant differentiation.
    """
    raise NotImplementedError(
        "Laplacian computation requires iterated covariant derivatives"
    )
